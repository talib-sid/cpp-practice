#include<bits/stdc++.h>
using namespace std;
 
#define int long long

signed main(){
    
    int tc;
    cin >> tc;
    while(tc--)
    {
        string str;
        int N;
        cin >> N;
        vector<int> v(N);
        for(int i = 0; i < N; i++){
            cin >> v[i];
        }
        int ans = 0;
    }
    return 0;
}

/*
RanPri
Slightly abnormal problem,
Input here is generated by yourself.

Charlie is trying to make some random numbers, with a seed he found lying around, and after he is done with finding these numbers,
he is curious to see how many of them are actually divisible with each other, he also loves the last element in this bunch 
and wishes to see if it would be a prime number or not.

Output:
In one line, Output the number of elements which are divisible by each other, 
Followed by 1/0 (1 indicating primality of the last number, 0 indicating otherwise)

Note:
DO Set your random seed to S and take modulo 93151 of the numbers getting generated. 



Waterlemon
The newest, most sought after addition to juice canteen is watermelon lemon, but the preparation is a bit difficult.
In order to achieve the "Perfect_G" waterlemon (G is the rating of how good the waterlemon is)  
you would need a ratio of watermelon and lemon such that the amount of lemon is perfectly splittable by that of the 
watermelons occurence in the prime_list, the rating of goodness is also how many perfect splits there can be.

In the unfortunate case where it is not perfectly splittable, an "Imperfect_B" waterlemon (B -.

 

Note: Prime list is just the list of the prime numbers (3, 5, 7, .....)
**Hardcoding this list for partial/full marks will incur a penantly**


0 < lemon < 1000
lemon <= watermelon  < 100000

Sol: 
Precalc prime numbers(sieve)
FInd a match with lemons, equal or bigger -> If == return Perfect_n/lemon, Else Imperfect_(n-lemon)

*/


/*

Waterlemon

The newest, most sought after addition to juice canteen is watermelon lemon, but the preparation is a bit difficult.
In order to achieve the "Perfect_G" waterlemon (G is the rating of how good the waterlemon is)  
you would need a ratio of watermelon and lemon such that the amount of lemon is perfectly splittable by that of the 
watermelons occurence in the prime_list, the rating of goodness is also how many perfect splits there can be.

In the unfortunate case where it is not perfectly splittable, an "Imperfect_B" waterlemon (B is the badness of the waterlemon)
needs to be given to the customer (printed out) with the rating of badness in this case being how many more lemons would 
be required to make it a perfect waterlemon.

 

Note: Prime list is just the list of the prime numbers (3, 5, 7, .....)
**Hardcoding this list for partial/full marks will incur a penantly**


0 < lemon < 1000
lemon <= watermelon  < 100000

Sol: 
Precalc prime numbers(sieve)
FInd a match with lemons, equal or bigger -> If == return Perfect_n/lemon, Else Imperfect_(n-lemon)

*/


/*
Snek and Ladder


Timothy and Chalamet are two very competetive friends, they fight in every sport competetively, even a simple board game,

You are given the snakes, ladders, starting positions of both the players,

Take 2 cases here now,
- Timothy's Turn
- Chalamet's Turn

Find out the minimum numbers of moves required for each player to win in their round 
(Calculate Timothy's win for Timothy's Turn and vice versa)

If the respective player CANNOT win their round, return -1


*/